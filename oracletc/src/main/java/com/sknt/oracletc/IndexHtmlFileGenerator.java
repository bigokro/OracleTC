/**
 * 
 */
package com.sknt.oracletc;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Scans a directory for HTML files generated by the XSLT transformation,
 * extracts the package name and total coverage scores, and generates
 * an HTML file summarizing the coverage information with links to the
 * detailed results.  
 *    
 * @author thigh
 *
 */
public class IndexHtmlFileGenerator {

	private static final String PACKAGE_DECLARATION_HEADER = "Coverage Report - ";
	private static final String PACKAGE_DECLARATION_TAIL = "</h5>";
	private static final String PROCEDURE_ROW_INDICATOR = "<a href=\"#";
	private static final String TOTAL_ROW_INDICATOR = "TOTAL";
	private static final String COVERAGE_STATS_HEADER = "<span class=\"text\">";
	private static final String COVERAGE_STATS_TAIL = "</span>";

	/**
	 * The default name of the output file, when none is supplied.
	 */
	private static final String DEFAULT_OUTPUT_FILE = "index.html"; 
	
	/**
	 * The directory containing the input HTML files, as transformed by the
	 * Oracle Test Coverage XSLT file. 
	 */
	private File inputDirectory;

	/**
	 * The "all" score index file that will be output by this object. 
	 */
	private File outputFile;
	
	/**
	 * The "best" score index file that will be output by this object (optional). 
	 */
	private File bestFile;
	
	/**
	 * The list of initial file names which define the groups of
	 * PL/SQL files to be compared when generating the "best" score report
	 */
	private List<String> bestOfGroups;
	
	/**
	 * When generating the "best" score:
	 * <code>true</code> indicates that the number of procedures in each file should considered; 
	 * 		any differences in this count indicate that the coverage should be considered separately
	 * <code>false</code> indicates that only one best score should be considered out of the whole group,
	 * 		regardless of any variations in the number of procedures in the files.
	 */
	private boolean considerNumProcs;
	
	public static void main(String[] args) {
		if (args.length == 0) {
			System.out.println("Usage: java com.sknt.oracletc.IndexHtmlFileGenerator <directory> [<outputFile>]");
			System.exit(0);
		}
		String directory = args[0];
		String file = null;
		String bestFile = null;
		String groups = null;
		boolean considerProcs = true;
		if (args.length > 1) {
			file = args[1];
		}
		
		if (args.length > 2) {
			bestFile = args[2];
		}

		List<String> groupsList = null;
		if (args.length > 3) {
			groups = args[3];
			groupsList = Arrays.asList(groups.split(",\\w*"));
		}

		if (args.length > 4) {
			considerProcs = Boolean.getBoolean(args[4]);
		}

		
		IndexHtmlFileGenerator generator = 
			new IndexHtmlFileGenerator(directory, file, bestFile, groupsList, considerProcs);
		System.out.format("Generating file %s using directory %s%n", generator.outputFile, generator.inputDirectory);
		try {
			generator.generateIndexFiles();
			System.out.println("File generation SUCCESSFUL");
		} catch (IOException e) {
			e.printStackTrace();
			System.out.println("File generation FAILED");
		}
	}
	
	/**
	 * Creates a new IndexHtmlFileGenerator for the input directory and output files
	 * indicated.
	 * If the name of the output file is null, the generated file will be output as 
	 * "index.html" in the input directory.
	 * 
	 * @param inputDirectoryPath A valid directory path formatted such that it can be used to create a {@link java.io.File} object. 
	 * @param outputFilePath A valid path name for the "all" score output file
	 * @param bestFilePath A valid path name for the "best" score output file (null = no "best" index)
	 * @throws IllegalArgumentException if the directory is null, doesn't exist, or isn't a directory
	 */
	public IndexHtmlFileGenerator(
			String inputDirectoryPath, 
			String outputFilePath, 
			String bestFilePath,
			List<String> groups,
			boolean considerNumProcs) {
		if (inputDirectoryPath == null) {
			throw new IllegalArgumentException("directory cannot be null");
		}
		inputDirectory = new File(inputDirectoryPath);
		if (!inputDirectory.exists()) {
			throw new IllegalArgumentException("Input directory does not exist: " + inputDirectoryPath);
		} else if (!inputDirectory.isDirectory()) {
			throw new IllegalArgumentException("Input directory provided is not a directory: " + inputDirectoryPath);
		}

		if (outputFilePath != null) {
			outputFile = new File(outputFilePath);
		} else {
			String fileName = inputDirectoryPath;
			fileName = fileName + (inputDirectoryPath.endsWith("/") ?  DEFAULT_OUTPUT_FILE : "/" + DEFAULT_OUTPUT_FILE);
			outputFile = new File(fileName);
		}
		
		if (bestFilePath != null) {
			bestFile = new File(bestFilePath);
		}
		
		this.bestOfGroups = groups;
		this.considerNumProcs = considerNumProcs;
	}
	
	/**
	 * Creates a new IndexHtmlFileGenerator for the input directory indicated.
	 * The generated file will be output as "index.html" in the input directory.
	 * No "best" index file will be generated.
	 * 
	 * @param directory
	 * @param outputFile
	 */
	public IndexHtmlFileGenerator(String directory) {
		this(directory, null, null, null, true);
	}

	/**
	 * Reads the HTML files in the configured directory, and outputs the summary index
	 * file to the specified filename.
	 * 
	 * If the bestOutputFile is set, a second file is output to that file name with the "best" score;
	 * that is, the score when considering only the file with most coverage out of groups of "similar" files.
	 * 
	 * If the output file already exists, it is first deleted.
	 * 
	 * @throws IOException 
	 */
	public void generateIndexFiles() throws IOException {
		outputFile.delete();
		List<File> inputFiles = listInputFiles();
		List<PackageCoverageStatistics> stats = gatherStats(inputFiles);
		writeIndexFile(outputFile, stats);

		if (bestFile != null) {
			List<PackageCoverageStatistics> bestStats = gatherBestStats(stats);
			writeIndexFile(bestFile, bestStats);
		}
	}

	
	/**
	 * Creates an array of HTML files contained in the target directory
	 */
	private List<File> listInputFiles() {
		File[] inputFiles = inputDirectory.listFiles(new FilenameFilter() {
		    public boolean accept(File dir, String name) {
		        return (name.endsWith(".html"));
		    }
		});
		
		
		return Arrays.asList(inputFiles);
	}

	/**
	 * Reads in the HTML files and returns a List of {@link PackageCoverageStatistics} objects.
	 * 
	 * @param stats
	 * @param inputFiles
	 * @return
	 */
	private List<PackageCoverageStatistics> gatherStats(List<File> inputFiles) {
		List<PackageCoverageStatistics> stats = new ArrayList<PackageCoverageStatistics>();
		
		for (File file : inputFiles) {
			try {
				PackageCoverageStatistics stat = readStats(file);
				stats.add(stat);
			} catch (IOException e) {
				// We want to continue - 
				// this shouldn't happen since the list of files comes from the directory
				e.printStackTrace();
			}
		}
		
		return stats;
	}

	/**
	 * Filters a list of statistics to identify "groups" of files / stats. 
	 * The groups are meant to represent sets of auto-generated PL/SQL code for which, given
	 * their similarity, it may be assumed a test executed on one file provides coverage for all. 
	 * 
	 * Groups are identified by the list of group names provided in the configuration.
	 * If the considerNumProcs option is set to <code>true</code>, then the groups are
	 * separated out by number of procedures (the assumption being that if the counts are
	 * different, the files are different enough to require separate coverage)
	 * 
	 * @param stats
	 * @return
	 */
	private List<PackageCoverageStatistics> gatherBestStats(
			List<PackageCoverageStatistics> stats) {
		Map<PackageCoverageStatisticsKey, PackageCoverageStatistics> groupStats = 
			new HashMap<PackageCoverageStatisticsKey, PackageCoverageStatistics>();
		for (PackageCoverageStatistics stat : stats) {
			PackageCoverageStatisticsKey groupKey = findGroupKey(stat);
			if (groupStats.containsKey(groupKey)) {
				testAndReplaceStat(groupStats, groupKey, stat);
			} else {
				groupStats.put(groupKey, stat);
			}
		}
		
		List<PackageCoverageStatistics> bestStats = new ArrayList<PackageCoverageStatistics>(stats);
		Iterator<PackageCoverageStatistics> iter = bestStats.iterator();
		while (iter.hasNext()) {
			PackageCoverageStatistics stat = iter.next();
			if (!groupStats.containsValue(stat)) {
				iter.remove();
			}
		}
		return bestStats;
	}

	/**
	 * Determines if this statistic is part of a group for the "best" score report
	 * If so, returns the group key based on name match and either procedure count,
	 * or -1 if the count is to be disconsidered. 
	 * 
	 * @param stat
	 * @return
	 */
	private PackageCoverageStatisticsKey findGroupKey(PackageCoverageStatistics stat) {
		PackageCoverageStatisticsKey key = null;
		String name = stat.getHtmlFileName();
		int count = -1;
		if (considerNumProcs) {
			count = stat.getNumProcedures();
		}
		
		for (String group : this.bestOfGroups) {
			if (name.startsWith(group)) {
				key = new PackageCoverageStatisticsKey(group, count);
				break;
			}
		}

		if (key == null) {
			key = new PackageCoverageStatisticsKey(name, count);
		}

		return key;
	}

	/**
	 * Gets the statistic set at the key, and compares  
	 * 
	 * @param groupStats
	 * @param stat
	 * @param groupKey
	 */
	private void testAndReplaceStat(
			Map<PackageCoverageStatisticsKey, PackageCoverageStatistics> groupStats,
			PackageCoverageStatisticsKey groupKey,
			PackageCoverageStatistics stat) {
		PackageCoverageStatistics highStat = groupStats.get(groupKey);
		if (stat.getRatioCovered() > highStat.getRatioCovered()) {
			groupStats.put(groupKey, stat);
		}
	}

	/**
	 * Reads in an HTML file, gathers the package-level stats, and returns
	 * an object containing those essential values.
	 * 
	 * @param file
	 * @return
	 * @throws IOException 
	 */
	private PackageCoverageStatistics readStats(File file) throws IOException {
		String fileName = file.getName();
		String packageName = null;
		int procedures = 0;
		int covered = -1;
		int total = -1;
		
		FileInputStream fis = new FileInputStream(file);
		InputStreamReader in = new InputStreamReader(fis, "UTF-8");
		BufferedReader reader = new BufferedReader(in);
		boolean totalLineFound = false;
		String line = null;
		while ((line = reader.readLine()) != null
				&& (packageName == null || covered == -1 || total == -1)) {
			if (line.contains(PACKAGE_DECLARATION_HEADER)) {
				packageName = line.substring(
						line.indexOf(PACKAGE_DECLARATION_HEADER) + PACKAGE_DECLARATION_HEADER.length(),
						line.indexOf(PACKAGE_DECLARATION_TAIL));
			} else if (line.contains(PROCEDURE_ROW_INDICATOR)) {
				procedures++;
			} else if (line.contains(TOTAL_ROW_INDICATOR)) {
				totalLineFound = true;
			} else if (line.contains(COVERAGE_STATS_HEADER) && totalLineFound) {
				covered = Integer.valueOf(
							line.substring(
								line.indexOf(COVERAGE_STATS_HEADER)+ COVERAGE_STATS_HEADER.length(), 
								line.indexOf('/')
							));
				total = Integer.valueOf(
							line.substring(
								line.indexOf('/') + 1,
								line.indexOf(COVERAGE_STATS_TAIL)
							));
			}
		}
		reader.close();

		PackageCoverageStatistics stat = new PackageCoverageStatistics(fileName, packageName, procedures, covered, total);
		return stat;
	}
	
	/**
	 * Generates the HTML index file based on the statistics provided
	 *  
	 * @param stats
	 * @throws IOException 
	 */
	private void writeIndexFile(File indexFile, List<PackageCoverageStatistics> stats) throws IOException {
		PackageCoverageStatistics totalStats = PackageCoverageStatistics.calculateTotal(stats);

		indexFile.createNewFile();
		FileOutputStream fos = new FileOutputStream(indexFile);
		OutputStreamWriter out = new OutputStreamWriter(fos, "UTF-8"); 

		writeHeader(out);
		writeBody(out, stats, totalStats);
		writeFooter(out);
		
		out.close();
	}

	/**
	 * Writes the index file header to the file
	 * @param out
	 * @throws IOException 
	 */
	private void writeHeader(OutputStreamWriter out) throws IOException {
		out.append("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n");
		out.append("           \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n");
		out.append("<html>\n");
		out.append("<head>\n");
		out.append("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>\n");
		out.append("<title>Oracle Test Coverage Report</title>\n");
		out.append("<link title=\"Style\" type=\"text/css\" rel=\"stylesheet\" href=\"css/main.css\"/>\n");
		out.append("<link title=\"Style\" type=\"text/css\" rel=\"stylesheet\" href=\"css/sortabletable.css\"/>\n");
		out.append("</head>\n");
		out.append("<body>\n");
		out.append("<h5>Oracle Test Coverage Report - All Packages</h5>\n");
		out.append("\n");
		out.append("<div class=\"separator\">&nbsp;</div>\n");
		out.append("<div class=\"footer\">Note: the total for \"all packages\" includes only those that have a number of total lines calculated.<br/>\n");
		out.append("Those listed as \"0% 0/0\" are not counted, resulting in a higher than actual percentage.</div>\n");
		out.append("<div class=\"separator\">&nbsp;</div>\n");
	}

	/**
	 * Generates and writes out the body HTML to the file
	 * 
	 * @param out
	 * @throws IOException 
	 */
	private void writeBody(OutputStreamWriter out, List<PackageCoverageStatistics> stats, PackageCoverageStatistics totalStats) throws IOException {
		out.append("<table class=\"report\" id=\"packageResults\">\n");
		out.append("<thead><tr>  <td class=\"heading\">Package</td>  <td class=\"heading\"># Procedures</td>  <td class=\"heading\">Line Coverage</td></tr></thead>\n");
		out.append("<tbody>\n");
		out.append(String.format("  <tr class=\"total\"><td class=\"title\">All Packages</td><td class=\"value\">%d</td><td><table cellpadding=\"0px\" cellspacing=\"0px\" class=\"percentgraph\"><tr class=\"percentgraph\"><td align=\"right\" class=\"percentgraph\" width=\"40\">%d%%</td><td class=\"percentgraph\"><div class=\"percentgraph\"><div class=\"greenbar\" style=\"width:%dpx\"><span class=\"text\">%d/%d</span></div></div></td></tr></table></td></tr>%n", 
				totalStats.getNumProcedures(), 
				totalStats.getPercentCovered(), 
				totalStats.getPercentCovered(), 
				totalStats.getLinesCovered(), 
				totalStats.getTotalLines()));
		out.append("\n");

		for (PackageCoverageStatistics stat : stats) {
			if (stat.getLinesCovered() < 0 || stat.getTotalLines() < 0) {
				// Invalid stat objects should be treated as having no coverage
				stat = new PackageCoverageStatistics(stat.getHtmlFileName(), stat.getPackageName(), 0, 0, 0);
			}
			
			String packageName = stat.getPackageName();
			if (packageName == null || stat.getPackageName().trim().equals("")) {
				if (stat.getHtmlFileName() == null || stat.getHtmlFileName().trim().equals("")) {
					packageName = "<name not found>";
				} else {
					packageName = stat.getHtmlFileName().substring(0, stat.getHtmlFileName().lastIndexOf('.'));
				}
			}
			out.append(String.format("  <tr><td><a href=\"%s\">%s</a></td><td class=\"value\">%d</td><td><table cellpadding=\"0px\" cellspacing=\"0px\" class=\"percentgraph\"><tr class=\"percentgraph\"><td align=\"right\" class=\"percentgraph\" width=\"40\">%d%%</td><td class=\"percentgraph\"><div class=\"percentgraph\"><div class=\"greenbar\" style=\"width:%dpx\"><span class=\"text\">%d/%d</span></div></div></td></tr></table></td></tr>%n",
					stat.getHtmlFileName(), 
					packageName,
					stat.getNumProcedures(), 
					stat.getPercentCovered(), 
					stat.getPercentCovered(), 
					stat.getLinesCovered(), 
					stat.getTotalLines()));
		}

		out.append("</tbody>\n");
		out.append("</table>\n");
	}

	/**
	 * Writes the index file footer to the file
	 * @param out
	 * @throws IOException 
	 */
	private void writeFooter(OutputStreamWriter out) throws IOException {
		Date date = new Date();

		out.append("\n");
		out.append("<div class=\"separator\">&nbsp;</div>\n");
		out.append(String.format("<div class=\"footer\">Report generated on %tc.</div>%n", date));
		out.append("\n");
		out.append("</body>\n");
		out.append("</html>\n");
	}

}
